模式总结
============
参考地址<https://segmentfault.com/a/1190000019470720?utm_medium=referral&utm_source=tuicool>
# 一、设计模式概略
 - 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
 - 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
 - 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
 
 # 二、设计模式之间的区别
 ## 1、装饰模式和代理模式有哪些区别 ？
 参考回答：

装饰器模式与代理模式的区别就在于
两者都是对类的方法进行扩展，但装饰器模式强调的是增强自身,在被装饰之后你能够在被增强的类上使用增强后的功能。
而代理模式则强调要让别人帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来
## 2、实现单例模式有几种方法 ？懒汉式中双层锁的目的是什么 ？两次判空的目的又是什么 ？
参考回答：

单例模式实现方法有多种：饿汉，懒汉(线程安全，线程非安全)，双重检查(DCL),内部类，以及枚举
所谓双层检验锁（在加锁前后对实例对象进行两次判空的检验）：加锁是为了第一次对象实例化的线程同步，而锁内还要有第二层判空是因为可能会有多个线程进入第一层if判断内部，而在加锁代码块外排队等候，如果锁内不进行第二次检验，仍然会出现实例化多个对象的情况。
## 3、回调函数和观察者模式的区别？
“标准答案”：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。观察者模式完美的将观察者和被观察的对象分离开，一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。
回调函数其实也算是一种观察者模式的实现方式，回调函数实现的观察者和被观察者往往是一对一的依赖关系。
所以最明显的区别是观察者模式是一种设计思路，而回调函数式一种具体的实现方式；另一明显区别是一对多还是多对多的依赖关系方面。

## 4、策略模式与状态模式的区别
 　　策略模式

Strategy: 定义所有支持的算法的公共接口抽象类.
ConcreteStrategy: 封装了具体的算法或行为，继承于Strategy
Context: 用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。
　　

 　　状态模式

State: 抽象状态类，定义一个接口以封装与context的一个状态相关的行为
ConcreteState: 具体状态，每一子类实现一个与Context的一个状态相关的行为
Context: 维护一个ConcreteState子类的实例，这个实例定义当前的状态。
使用场景：

　　状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。

　　策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。
  
  详细的可参考地址<https://www.cnblogs.com/m7777/p/7723879.html>
  
  # 三、android中常用的设计模式
  参考是地址<https://www.cnblogs.com/lenkevin/p/8692490.html>
  
  
  
